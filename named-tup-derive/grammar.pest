/// This parser doesn't care about getting the correct rust parsing since we can offload that all off to the macros
/// We just want to make sure than any correct macros are correctly parsed, thus we need to parse strings to check
/// for commas and parentheses and not parse them as if they were not in a string.

WHITESPACE = _{ " " }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

ident_char = _{ 'a'..'z' | 'A'..'Z' | '0'..'9' | "_" }
ident =  @{
    ('a'..'z' | 'A'..'Z') ~ ident_char* |
    "_" ~ ident_char+
}

// Necessary as a string may be hiding a "," which could cause an incorrect result
predefined = _{ "n" | "r" | "t" | "\\" | "0" | "\"" | "'" }
byte       = _{ "x" ~ hex{2} }
unicode    = _{ "u" ~ "_{" ~ unicode_hex ~ "}" }
escape     = _{ "\\" ~ (predefined | byte | unicode) }
unicode_hex = _{ hex{1, 6} }
hex = _{ '0'..'9' | 'a'..'f' | 'A'..'F' }
raw_string = _{ (!("\\" | "\"") ~ ANY)+ }
string = _{ "\"" ~ (raw_string | escape)* ~ "\"" }

char = _{ !( "(" | ")" | "," ) ~ ANY}
char_inside = _{ !( "(" | ")" ) ~ ANY}

expr_inside = _{ string | char_inside+ ~ NEWLINE? ~ ("(" ~ NEWLINE? ~ (expr_inside | "") ~ NEWLINE? ~ ")")? | "(" ~ NEWLINE? ~ (expr_inside | "") ~ NEWLINE? ~ ")" }
expr        = _{ string | char+        ~ NEWLINE? ~ ("(" ~ NEWLINE? ~ (expr_inside | "") ~ NEWLINE? ~ ")")? | "(" ~ NEWLINE? ~ (expr_inside | "") ~ NEWLINE? ~ ")" }

arguments = _{ (ident ~ NEWLINE? ~ ":" ~ NEWLINE? ~ expr) | ident }
tup = _{ "tup" ~ NEWLINE? ~ "!" ~ NEWLINE? ~ "(" ~ NEWLINE? ~ arguments ~ NEWLINE? ~ ("," ~ NEWLINE? ~ arguments ~ NEWLINE?)* ~ NEWLINE? ~ ")" }
file = _{ (tup | ANY)* }